---
title: Autonomous Workflows with agents.mdx
description: Enable complete development autonomy through MDX-defined workflows
---

# Autonomous Workflows

## The Problem

You've got a roadmap. Issues are tracked with dependencies. Claude Code can implement any task you throw at it. But there's a bottleneck: **you**.

Every time an agent finishes work and merges a PR:
- Someone has to notice
- Someone has to decide what's next
- Someone has to trigger the next agent

This human-in-the-loop is the constraint. The system waits for you.

## The Solution

**Workflows** â€” TypeScript code in MDX that defines what happens automatically.

```typescript
// .workflows/develop.mdx
on.issue.ready(async (issue) => {
  const diff = await claude.spawn({ repo, task: issue })
  const pr = await github.pr.create({ diff, issue })
  await pr.waitForApproval()
  await github.pr.merge(pr)
  await beads.close(issue.id)
})
```

When an issue becomes unblocked:
1. Claude spawns automatically
2. Implements the feature
3. Creates a PR
4. Another Claude reviews it
5. Merges if approved
6. Closes the issue
7. Dependent issues unblock
8. More Claudes spawn

**The roadmap executes itself.**

## How It Works

### Write Workflows in MDX

```mdx
<!-- .workflows/develop.mdx -->
# Auto-develop Ready Issues

When an issue becomes ready (no blockers), spawn Claude to implement it.

```typescript
on.issue.ready(async (issue) => {
  // Full project context
  const context = todo.render()

  // Spawn Claude in the cloud
  const result = await claude.spawn({
    repo: github.repo,
    task: issue.description,
    context
  })

  // Create PR with the diff
  const pr = await github.pr.create({
    branch: `${issue.id}-${slugify(issue.title)}`,
    title: issue.title,
    body: `Closes #${issue.id}\n\n${result.summary}`
  })

  // Code review by another Claude
  const review = await claude.review(pr)

  if (review.approved) {
    await github.pr.merge(pr)
    await beads.close(issue.id)
    await slack.notify('#dev', `âœ… Merged: ${issue.title}`)
  } else {
    // Claude iterates on feedback
    await claude.spawn({
      repo: github.repo,
      task: `Address review feedback: ${review.comments}`,
      branch: pr.branch
    })
  }
})
```
```

### The API Surface

Workflows have access to a unified API:

| Namespace | Purpose |
|-----------|---------|
| `claude` | Spawn agents, code review, ask questions |
| `github` | PRs, issues, repos, actions |
| `git` | Worktrees, commits, branches |
| `beads` | Issue tracking, dependencies, epics |
| `todo` | Render realtime project context |
| `slack` | Notifications |

### Triggers

| Trigger | When |
|---------|------|
| `on.issue.ready` | Issue has no blockers |
| `on.issue.closed` | Issue completed |
| `on.issue.created` | New issue opened |
| `on.pr.merged` | Pull request merged |
| `on.pr.reviewed` | PR received review |
| `on.epic.completed` | All children closed |
| `every.hour` | Scheduled hourly |
| `every.day` | Scheduled daily |

## Architecture

### Local Mode (v1)

```
.workflows/*.mdx
      â”‚
      â”‚ parsed
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Local Daemon    â”‚
â”‚                 â”‚
â”‚ - File watcher  â”‚
â”‚ - beads events  â”‚
â”‚ - Proxy runtime â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Local Execution â”‚
â”‚                 â”‚
â”‚ - claude CLI    â”‚
â”‚ - git commands  â”‚
â”‚ - octokit       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Run with:
```bash
workflows watch
```

### Cloud Mode (v2)

```
GitHub Webhooks
      â”‚
      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           todo.mdx.do Worker            â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Repo DO     â”‚  â”‚ Cloudflare      â”‚  â”‚
â”‚  â”‚             â”‚â”€â”€â”‚ Workflows       â”‚  â”‚
â”‚  â”‚ Per-repo    â”‚  â”‚                 â”‚  â”‚
â”‚  â”‚ state       â”‚  â”‚ step.do()       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ step.waitFor()  â”‚  â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                           â”‚            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚            â”‚
â”‚  â”‚ Worker      â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚  â”‚ Loader      â”‚                      â”‚
â”‚  â”‚             â”‚                      â”‚
â”‚  â”‚ Dynamic     â”‚                      â”‚
â”‚  â”‚ workflow    â”‚                      â”‚
â”‚  â”‚ modules     â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚         â”‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚ CapnWeb     â”‚                      â”‚
â”‚  â”‚             â”‚                      â”‚
â”‚  â”‚ Sandboxed   â”‚                      â”‚
â”‚  â”‚ execution   â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Cloudflare Sandbox              â”‚
â”‚                                         â”‚
â”‚  - Clones repo                          â”‚
â”‚  - Claude JWT from WorkOS vault         â”‚
â”‚  - Runs Claude Code                     â”‚
â”‚  - Returns diff                         â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key technologies:**
- **Cloudflare Workflows** â€” Durable execution with `step.do()` for retries and `step.waitForEvent()` for pausing days waiting for PR approval
- **CapnWeb** â€” Secure sandbox for arbitrary workflow code
- **Worker Loader** â€” Dynamically load per-repo workflow modules
- **Cloudflare Sandbox** â€” Run Claude Code in the cloud

## The Proxy Pattern

The same TypeScript code runs locally and in the cloud. A Proxy on `globalThis` abstracts the execution:

```typescript
// Workflow code
const diff = await claude.spawn({ task: issue })
```

**Locally:**
```typescript
// Proxy routes to
await exec('claude', ['--task', issue.description])
```

**In cloud:**
```typescript
// Proxy routes to
await env.SANDBOX.spawn({
  repo: repoUrl,
  task: issue.description,
  token: await vault.get('claude_jwt')
})
```

Same code, different backends.

## Authentication

Workflows run with your credentials, stored securely:

```bash
$ agents.mdx auth

1. Opening oauth.do...
2. Authenticating Claude Code CLI...
3. Storing tokens in WorkOS vault...

âœ“ Authenticated
```

Tokens stored:
- **Claude JWT** â€” Long-lived token for Claude Code
- **GitHub Token** â€” For PRs, issues, repos
- **WorkOS Token** â€” For vault access

When a workflow spawns Claude in the cloud, it fetches your tokens from the vault and passes them to the Sandbox.

## Examples

### Continuous Development

```typescript
// .workflows/continuous.mdx
on.issue.ready(async (issue) => {
  // Parallel: spawn Claude AND notify
  await Promise.all([
    claude.spawn({ task: issue }),
    slack.notify('#dev', `ðŸš€ Starting: ${issue.title}`)
  ])
})

on.pr.merged(async (pr) => {
  // Find and close the issue
  const issueId = extractIssueId(pr.body)
  if (issueId) {
    await beads.close(issueId)
  }
})
```

### Daily Standup Bot

```typescript
// .workflows/standup.mdx
every.day('9:00', async () => {
  const ready = await beads.issues.ready()
  const blocked = await beads.issues.blocked()
  const inProgress = await beads.issues.list({ status: 'in_progress' })

  await slack.notify('#standup', `
## Daily Update

**Ready:** ${ready.length} issues
**In Progress:** ${inProgress.length} issues
**Blocked:** ${blocked.length} issues

### Next Up
${todo.ready(3)}
  `)
})
```

### Epic Auto-close

```typescript
// .workflows/epics.mdx
on.issue.closed(async (issue) => {
  // Check if parent epic is complete
  for (const epicId of issue.blocks) {
    const progress = await beads.epics.progress(epicId)

    if (progress.percentage === 100) {
      await beads.close(epicId)
      await slack.notify('#dev', `ðŸŽ‰ Epic complete: ${progress.epic.title}`)
    }
  }
})
```

### Code Review Loop

```typescript
// .workflows/review.mdx
on.pr.created(async (pr) => {
  // Auto-assign Claude as reviewer
  const review = await claude.review(pr)

  if (review.approved) {
    await github.pr.approve(pr)
  } else {
    await github.pr.comment(pr, review.feedback)
    await github.pr.requestChanges(pr)
  }
})

on.pr.updated(async (pr) => {
  // Re-review after changes
  if (pr.reviewState === 'changes_requested') {
    const review = await claude.review(pr)

    if (review.approved) {
      await github.pr.approve(pr)
    }
  }
})
```

## The Vision

**Today:** You plan, you assign, you trigger, you review, you merge.

**With workflows:** You plan. The system does the rest.

Define your roadmap with dependencies. Write workflow rules. Watch as:
- Issues get implemented automatically
- PRs get created and reviewed
- Code gets merged when ready
- Dependent work unblocks and continues
- The roadmap completes itself

This is **autonomous development**.

## Getting Started

```bash
# Install
npm install agents.mdx

# Authenticate
agents.mdx auth

# Create your first workflow
mkdir .workflows
cat > .workflows/develop.mdx << 'EOF'
# Auto-develop

```typescript
on.issue.ready(async (issue) => {
  await claude.spawn({ task: issue })
})
```
EOF

# Run locally
agents.mdx watch

# Or deploy to cloud
agents.mdx deploy
```
