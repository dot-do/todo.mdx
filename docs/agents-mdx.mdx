---
title: agents.mdx
description: Autonomous workflow orchestration - write TypeScript in MDX, execute locally or in the cloud
---

# agents.mdx

**Workflow orchestration runtime that abstracts local vs cloud execution.** Write TypeScript workflows once in MDX files, run them anywhere - local daemon or Cloudflare Workers with durable execution.

## The Core Insight

Workflows are TypeScript code that runs in two very different environments:

- **Locally:** Shell out to `claude`, `git`, `bd` CLI tools
- **Cloud:** Call Workers RPC, Cloudflare Sandbox, GitHub API

The same workflow code works in both environments thanks to a **proxy runtime** that routes method calls to the appropriate backend.

## Installation

```bash
npm install agents.mdx
# or
pnpm add agents.mdx
# or
bun add agents.mdx
```

## Quick Start

### 1. Create a Workflow

Create `.workflows/develop.mdx`:

```mdx
---
title: Auto-develop Ready Issues
description: Automatically implement issues when they become unblocked
---

# Development Workflow

When an issue becomes ready (no blockers), spawn Claude to implement it.

```typescript
on.issue.ready(async (issue) => {
  // Full project context
  const context = await todo.render()

  // Spawn Claude to implement
  const result = await claude.do({
    task: issue.description,
    context
  })

  // Create PR with the changes
  const pr = await pr.create({
    branch: `${issue.id}-${issue.title}`,
    title: issue.title,
    body: `Closes #${issue.id}\n\n${result.summary}`
  })

  // Wait for approval (can pause for days)
  await pr.waitForApproval(pr)

  // Merge and close
  await pr.merge(pr)
  await issues.close(issue.id)
})
```
```
```

### 2. Run Locally

```bash
# Start workflow daemon
npx agents.mdx watch

# Or with explicit repo
npx agents.mdx watch --repo owner/name
```

The daemon:
- Watches `.workflows/*.mdx` files for changes
- Monitors beads issue events
- Executes matching workflow handlers
- Hot-reloads on file changes

### 3. Deploy to Cloud

Workflows automatically run in Cloudflare Workers when deployed to todo.mdx.do. They gain:
- **Durable execution** via Cloudflare Workflows
- **Automatic retries** on transient failures
- **Long waits** via `step.waitForEvent()` (days/weeks without holding resources)
- **Cloudflare Sandbox** for isolated code execution

## How It Works

### Single Source, Multiple Runtimes

The same workflow code runs in different environments:

```typescript
// This line works everywhere
const result = await claude.do({ task: 'implement feature' })
```

**Local runtime:**
```typescript
// Routes to Claude CLI
await exec('claude', ['--task', 'implement feature'])
```

**Cloud runtime:**
```typescript
// Routes to Cloudflare Sandbox via Workers RPC
await env.CLAUDE_SANDBOX.spawn({
  task: 'implement feature',
  token: await vault.get('claude_jwt')
})
```

### Workflow Runtime API

All workflows have access to a unified runtime:

```typescript
interface WorkflowRuntime {
  // Context
  repo: Repo              // Current repository
  issue?: Issue           // Triggering issue (if applicable)

  // Namespaces
  claude: Claude          // AI agent operations
  pr: PRNamespace         // Pull requests
  issues: IssuesNamespace // Issue tracking
  epics: EpicsNamespace   // Epic management
  git: GitNamespace       // Git operations
  todo: TodoNamespace     // Context rendering
}
```

## Workflow File Format

Workflows are MDX files in `.workflows/` directory:

```mdx
---
# Frontmatter (optional)
name: auto-develop
description: Automatically implement ready issues
enabled: true
tags: [automation, claude]
---

# Workflow Documentation

Markdown documentation explaining what this workflow does.

```typescript
// TypeScript code with event handlers
on.issue.ready(async (issue) => {
  // Implementation
})

every.day('9am', async () => {
  // Scheduled task
})
```
```
```

### Frontmatter Options

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `name` | string | filename | Workflow name override |
| `description` | string | - | Human-readable description |
| `enabled` | boolean | true | Whether workflow is active |
| `tags` | string[] | [] | Tags for filtering/organization |

## Event Triggers

### Issue Events

```typescript
// When issue has no blockers
on.issue.ready(async (issue) => {
  await claude.do({ task: issue.title })
})

// When issue is created
on.issue.created(async (issue) => {
  await issues.update(issue.id, { assignee: 'claude-bot' })
})

// When issue is updated
on.issue.updated(async (issue) => {
  // Handle updates
})

// When issue is closed
on.issue.closed(async (issue) => {
  // Check if parent epic is complete
})
```

### Epic Events

```typescript
// When all child issues are closed
on.epic.completed(async (epic) => {
  await slack.notify('#dev', `Epic complete: ${epic.title}`)
})
```

### Scheduled Events

```typescript
// Daily at 9am
every.day('9am', async () => {
  const ready = await issues.ready()
  await slack.notify('#standup', `${ready.length} issues ready`)
})

// Every hour
every.hour(async () => {
  // Hourly task
})

// Every minute (use sparingly!)
every.minute(async () => {
  // Frequent task
})

// Weekly on Monday at 9am
every.week('monday', '9am', async () => {
  // Weekly task
})
```

## Runtime API Reference

### Claude Namespace

Execute AI agent operations:

```typescript
// Template literal style
const result = await claude`implement ${feature}`
const answer = await claude.ask`how should I handle ${edgeCase}?`

// Structured style
const result = await claude.do({
  task: 'implement authentication',
  context: 'Use JWT tokens',
  model: 'opus' // or 'sonnet', 'haiku'
})

const research = await claude.research({
  topic: 'best approach for auth',
  depth: 'thorough', // or 'quick', 'exhaustive'
  context: 'Building a SaaS product'
})

const review = await claude.review({
  pr: pullRequest,
  focus: ['security', 'performance', 'correctness', 'style']
})

const answer = await claude.ask({
  question: 'What pattern should I use?',
  context: 'Building a CLI tool'
})
```

**Result Types:**

```typescript
interface DoResult {
  diff: string              // Git diff of changes
  summary: string           // Human-readable summary
  filesChanged: string[]    // List of modified files
}

interface ResearchResult {
  findings: string          // Research findings
  sources: string[]         // Source URLs
  confidence: 'high' | 'medium' | 'low'
}

interface ReviewResult {
  approved: boolean         // Whether PR is approved
  comments: Array<{         // Review comments
    file: string
    line: number
    body: string
    severity: 'critical' | 'warning' | 'suggestion'
  }>
  summary: string           // Overall review summary
}
```

### PR Namespace

Manage pull requests:

```typescript
// Create PR
const pr = await pr.create({
  branch: 'feature-branch',
  title: 'Add authentication',
  body: 'Implements JWT-based auth'
})

// Merge PR
await pr.merge(pr)

// Add comment
await pr.comment(pr, 'LGTM!')

// Wait for approval (pauses workflow)
await pr.waitForApproval(pr, {
  timeout: '7d' // Wait up to 7 days
})

// List PRs
const openPRs = await pr.list({ state: 'open' })
```

### Issues Namespace

Manage issues via beads or GitHub:

```typescript
// List issues with filters
const issues = await issues.list({
  status: 'open',
  priority: 1,
  type: 'feature',
  assignee: 'claude-bot',
  labels: ['bug', 'critical']
})

// Get ready issues (no blockers)
const ready = await issues.ready()

// Get blocked issues
const blocked = await issues.blocked()

// Create issue
const issue = await issues.create({
  title: 'Add dark mode',
  description: 'Implement dark mode toggle',
  type: 'feature',
  priority: 2
})

// Update issue
await issues.update(issue.id, {
  status: 'in_progress',
  assignee: 'claude-bot'
})

// Close issue
await issues.close(issue.id, 'Completed via workflow')

// Get issue details
const issue = await issues.show('todo-abc')
```

### Epics Namespace

Manage epics (parent issues):

```typescript
// List all epics
const epics = await epics.list()

// Get epic progress
const progress = await epics.progress('epic-123')
// { total: 10, completed: 7, percentage: 70 }

// Create epic
const epic = await epics.create({
  title: 'v1.0 Release',
  description: 'All features for v1.0'
})
```

### Git Namespace

Execute git operations:

```typescript
// Commit changes
const sha = await git.commit('feat: add authentication')

// Push to remote
await git.push('feature-branch')

// Pull from remote
await git.pull()

// Create branch
await git.branch('new-feature')

// Checkout ref
await git.checkout('main')

// Get status
const status = await git.status()
// { modified: [...], staged: [...], untracked: [...] }

// Get diff
const diff = await git.diff('main')

// Worktree management
const path = await git.worktree.create('feature-branch')
await git.worktree.remove('feature-branch')
const worktrees = await git.worktree.list()
```

### Todo Namespace

Render live project context:

```typescript
// Render full TODO.md
const markdown = await todo.render()

// Get ready issues as markdown
const ready = await todo.ready(5) // Limit to 5

// Get blocked issues
const blocked = await todo.blocked()

// Get in-progress issues
const inProgress = await todo.inProgress()
```

## CLI Commands

### Authentication

```bash
# Authenticate via oauth.do
agents.mdx auth

# Check authentication status
agents.mdx status

# Logout (clear credentials)
agents.mdx logout
```

The `auth` command opens oauth.do in your browser and stores three tokens:
- **Claude JWT:** Long-lived token for Claude Code
- **GitHub Token:** For PRs, issues, repos
- **WorkOS Token:** For vault access

Tokens are stored in `~/.agents.mdx/tokens.json` with strict permissions (0600).

### Daemon Mode

```bash
# Start workflow daemon (auto-detect repo from git)
agents.mdx watch

# Explicit repo
agents.mdx watch --repo owner/name

# Custom workflows directory
agents.mdx watch --workflows ./my-workflows

# Custom beads directory
agents.mdx watch --beads ./.beads

# Enable debug logging
agents.mdx watch --debug

# Show help
agents.mdx watch --help
```

The daemon:
- Watches `.workflows/*.mdx` files for changes
- Hot-reloads workflows when files change
- Monitors beads events (via optional `beads-workflows` package)
- Executes matching event handlers
- Logs workflow registrations and executions

### Help

```bash
# Show all commands
agents.mdx help

# Command-specific help
agents.mdx watch --help
```

## Daemon Configuration

### Auto-detect Repository

The daemon automatically detects the repository from git remote:

```bash
# Uses git remote get-url origin
agents.mdx watch
```

### Explicit Repository

Override auto-detection:

```bash
agents.mdx watch --repo dot-do/todo.mdx
```

### Custom Directories

```bash
# Custom workflows directory (default: .workflows or workflows)
agents.mdx watch --workflows ./custom-workflows

# Custom beads directory (default: .beads)
agents.mdx watch --beads ./custom-beads

# Custom working directory
agents.mdx watch --cwd /path/to/project
```

### Debug Mode

Enable verbose logging:

```bash
agents.mdx watch --debug
```

Logs:
- Workflow file changes
- Event triggers
- Handler executions
- Compilation errors
- Registration details

## Programmatic Usage

### Create Runtime

```typescript
import { createRuntime, localTransport } from 'agents.mdx'

const runtime = createRuntime({
  repo: {
    owner: 'dot-do',
    name: 'todo.mdx',
    defaultBranch: 'main',
    url: 'https://github.com/dot-do/todo.mdx'
  },
  transport: localTransport({ repo })
})

// Use runtime
const result = await runtime.claude.do({ task: 'fix the bug' })
```

### Parse Workflows

```typescript
import { parseWorkflowFile, loadWorkflows } from 'agents.mdx'

// Parse single file
const content = await readFile('.workflows/develop.mdx', 'utf-8')
const workflow = parseWorkflowFile(content, '.workflows/develop.mdx')

// Parse all workflows in directory
const workflows = await loadWorkflows('.workflows')
```

### Compile Workflows

```typescript
import { compileWorkflow, executeWorkflow } from 'agents.mdx'

// Compile parsed workflow
const compiled = compileWorkflow(parsed)

if (compiled.success) {
  // Execute with runtime
  const registration = executeWorkflow(compiled, runtime)

  console.log('Registered handlers:')
  for (const [event, handlers] of Object.entries(registration.handlers)) {
    console.log(`  ${event}: ${handlers.length} handlers`)
  }
}
```

### Start Daemon Programmatically

```typescript
import { WorkflowDaemon } from 'agents.mdx'

const daemon = new WorkflowDaemon({
  repo: {
    owner: 'dot-do',
    name: 'todo.mdx',
    defaultBranch: 'main',
    url: 'https://github.com/dot-do/todo.mdx'
  },
  workflowsDir: '.workflows',
  beadsDir: '.beads',
  debug: true
})

await daemon.start()

// Later...
await daemon.stop()
```

## Cloud Execution (Cloudflare Workflows)

### Durable Transport

Use `durableTransport` for workflows running in Cloudflare Workers:

```typescript
import { WorkflowEntrypoint, WorkflowStep } from 'cloudflare:workers'
import { createRuntime, durableTransport } from 'agents.mdx/cloudflare-workflows'

export class DevelopWorkflow extends WorkflowEntrypoint {
  async run(event, step: WorkflowStep) {
    const runtime = createRuntime({
      repo: event.payload.repo,
      issue: event.payload.issue,
      transport: durableTransport(step, {
        repo: event.payload.repo,
        payloadBinding: this.env.PAYLOAD,
        claudeBinding: this.env.CLAUDE_SANDBOX,
        installationId: event.payload.installationId
      })
    })

    // All calls are now durable!
    const result = await runtime.claude.do({ task: issue.title })

    // Create PR
    const pr = await runtime.pr.create({
      branch: `${issue.id}`,
      title: issue.title,
      body: result.summary
    })

    // Wait for approval (can pause for days)
    await runtime.pr.waitForApproval(pr, { timeout: '7d' })

    // Merge
    await runtime.pr.merge(pr)
  }
}
```

### Durability Features

**Automatic Retries:**
All runtime calls are wrapped in `step.do()` for automatic retries on transient failures.

**Long Waits:**
`pr.waitForApproval()` uses `step.waitForEvent()` to pause the workflow without holding resources. The workflow can wait days/weeks and automatically resume when the event fires.

**Step Prefixes:**
Add prefixes to all step names for easier debugging:

```typescript
transport: durableTransport(step, {
  // ... other config
  stepPrefix: issue.id // All steps: "todo-123.claude.do", "todo-123.pr.create"
})
```

**Custom Event Names:**
Override default event names:

```typescript
transport: durableTransport(step, {
  // ... other config
  eventNames: {
    prApproval: (pr) => `repo-${repo.name}-pr-${pr.number}-approved`
  }
})
```

### Webhook Integration

Send events to resume paused workflows:

```typescript
// When PR is approved (webhook handler)
import { prApprovalEvent } from 'agents.mdx/cloudflare-workflows'

app.post('/github/webhook', async (c) => {
  const payload = await c.req.json()

  if (payload.action === 'submitted' && payload.review?.state === 'approved') {
    const pr = payload.pull_request
    const eventName = prApprovalEvent(pr) // "pr.123.approved"

    // Workflow automatically resumes
    await c.env.DEVELOP_WORKFLOW.sendEvent(eventName, {
      approved: true,
      reviewer: payload.review.user.login
    })
  }

  return c.json({ status: 'ok' })
})
```

**Event Helpers:**

```typescript
import {
  prApprovalEvent,
  issueReadyEvent,
  epicCompletedEvent
} from 'agents.mdx/cloudflare-workflows'

// Generate event names
prApprovalEvent({ number: 123 })        // "pr.123.approved"
issueReadyEvent('todo-abc')             // "issue.todo-abc.ready"
epicCompletedEvent('epic-xyz')          // "epic.epic-xyz.completed"
```

### Workflow Configuration

Add to `wrangler.toml`:

```toml
[[workflows]]
binding = "DEVELOP_WORKFLOW"
name = "develop-workflow"
class_name = "DevelopWorkflow"

# Service bindings
[[workflows.bindings]]
type = "service"
binding = "PAYLOAD"
service = "todo-mdx-payload"

[[workflows.bindings]]
type = "service"
binding = "CLAUDE_SANDBOX"
service = "claude-sandbox"
```

## Transport Abstraction

The transport layer abstracts how runtime calls are executed:

### Local Transport

Routes calls to CLI tools:

```typescript
import { localTransport } from 'agents.mdx/local'

const transport = localTransport({
  repo: {
    owner: 'dot-do',
    name: 'todo.mdx',
    defaultBranch: 'main',
    url: 'https://github.com/dot-do/todo.mdx'
  },
  cwd: process.cwd()
})
```

**Routes:**
- `claude.*` → `claude` CLI via Bun subprocess
- `git.*` → `git` CLI
- `issues.*`, `epics.*` → `bd` CLI (beads)
- `pr.*` → Octokit (GitHub API)
- `todo.*` → Read `TODO.md` file

### Cloud Transport

Routes calls to Workers RPC and APIs:

```typescript
import { cloudTransport } from 'agents.mdx/cloud'

const transport = cloudTransport({
  repo,
  payloadBinding: env.PAYLOAD,
  claudeBinding: env.CLAUDE_SANDBOX,
  installationId: 123456,
  apiBaseUrl: 'https://todo.mdx.do/api'
})
```

**Routes:**
- `claude.*`, `git.*` → Cloudflare Sandbox via Workers RPC
- `issues.*`, `epics.*` → Payload CMS via Workers RPC
- `pr.*` → GitHub API via installation tokens
- `todo.*` → todo.mdx API

### Durable Transport

Wraps cloud transport with Cloudflare Workflows durability:

```typescript
import { durableTransport } from 'agents.mdx/cloudflare-workflows'

const transport = durableTransport(step, {
  repo,
  payloadBinding: env.PAYLOAD,
  // ... other cloud transport config
  useDurableSteps: true,
  stepPrefix: 'workflow-123'
})
```

**Features:**
- All calls wrapped in `step.do()` for automatic retries
- `pr.waitForApproval()` uses `step.waitForEvent()`
- Configurable step naming and event mapping

## Complete Example: Auto-develop Workflow

```mdx
---
title: Autonomous Development
description: Automatically implement, review, and merge ready issues
enabled: true
tags: [automation, claude, continuous-development]
---

# Autonomous Development Workflow

This workflow automatically implements issues when they become ready (no blockers).

## Flow

1. Issue becomes ready (no blockers)
2. Claude spawns to implement
3. PR created with changes
4. Claude reviews the PR
5. Wait for human approval
6. Merge and close issue
7. Dependent issues unblock

```typescript
on.issue.ready(async (issue) => {
  console.log(`Starting work on ${issue.id}: ${issue.title}`)

  // Mark as in progress
  await issues.update(issue.id, {
    status: 'in_progress',
    assignee: 'claude-bot'
  })

  // Get full project context
  const context = await todo.render()

  // Spawn Claude to implement
  let result
  try {
    result = await claude.do({
      task: issue.title,
      context,
      model: 'opus' // Use best model for implementation
    })
  } catch (error) {
    // Mark as blocked if implementation fails
    await issues.update(issue.id, {
      status: 'blocked'
    })
    throw new Error(`Implementation failed: ${error}`)
  }

  console.log(`Implementation complete: ${result.filesChanged.length} files changed`)

  // Create PR
  const branch = `${issue.id}-${slugify(issue.title)}`
  const pr = await pr.create({
    branch,
    title: issue.title,
    body: `
Closes #${issue.id}

## Summary

${result.summary}

## Changes

\`\`\`diff
${result.diff}
\`\`\`

---
Implemented by Claude via autonomous workflow
    `.trim()
  })

  console.log(`Created PR #${pr.number}: ${pr.url}`)

  // Code review by Claude
  const review = await claude.review({
    pr,
    focus: ['security', 'correctness', 'performance']
  })

  if (!review.approved) {
    console.log(`Review failed with ${review.comments.length} critical issues`)

    // Post review feedback
    await pr.comment(pr, `
## Code Review

${review.summary}

### Issues Found

${review.comments.map(c => `
- **${c.file}:${c.line}** (\`${c.severity}\`)
  ${c.body}
`).join('\n')}

@human Please review and decide whether to proceed.
    `.trim())

    // Mark as blocked - needs human intervention
    await issues.update(issue.id, {
      status: 'blocked'
    })

    throw new Error(`Code review failed: ${review.summary}`)
  }

  console.log(`Code review passed: ${review.summary}`)

  // Wait for human approval
  console.log('Waiting for PR approval...')

  try {
    await pr.waitForApproval(pr, {
      timeout: '7d' // Wait up to 7 days
    })
  } catch (error) {
    console.log('PR approval timed out')

    await issues.update(issue.id, {
      status: 'blocked'
    })

    throw new Error('PR approval timeout - manual intervention required')
  }

  console.log('PR approved! Merging...')

  // Merge PR
  await pr.merge(pr)

  console.log('PR merged')

  // Close issue
  await issues.close(issue.id, 'Completed via autonomous workflow')

  console.log(`Issue ${issue.id} closed. Workflow complete!`)

  // Note: Dependent issues will automatically unblock
})

// Helper function
function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 50)
}
```
```
```

## Integration with todo.mdx

agents.mdx works seamlessly with todo.mdx for project context:

```typescript
// In workflow
on.issue.ready(async (issue) => {
  // Render full TODO.md for context
  const context = await todo.render()

  // Or get specific sections
  const ready = await todo.ready(5)
  const blocked = await todo.blocked()
  const inProgress = await todo.inProgress()

  // Pass to Claude
  await claude.do({
    task: issue.title,
    context: `
# Project Context

${context}

## Focus

Implement: ${issue.title}
    `
  })
})
```

## Integration with beads

agents.mdx uses beads for issue tracking and dependency management:

```typescript
// Issue management
const issues = await issues.list({
  status: 'open',
  priority: 1
})

const ready = await issues.ready()
const blocked = await issues.blocked()

// Dependencies
await issues.update(issue.id, {
  status: 'blocked',
  blockedBy: ['other-issue-id']
})

// When issue is closed, dependent issues automatically unblock
await issues.close(issue.id)
```

## Integration with AI Assistants

Workflows can leverage any AI assistant with the runtime API:

```typescript
// Claude Code (default)
await claude.do({ task: 'implement feature' })

// Ask questions
const answer = await claude.ask({
  question: 'What is the best approach for authentication?',
  context: 'Building a SaaS product with Next.js'
})

// Research topics
const research = await claude.research({
  topic: 'database scaling strategies',
  depth: 'thorough'
})

// Code review
const review = await claude.review({
  pr: pullRequest,
  focus: ['security', 'performance']
})
```

## Type Definitions

Complete TypeScript types are available:

```typescript
import type {
  // Domain types
  Repo,
  Issue,
  PR,
  IssueFilter,

  // Runtime types
  WorkflowRuntime,
  RuntimeConfig,
  Transport,

  // Claude types
  DoOpts,
  DoResult,
  ResearchOpts,
  ResearchResult,
  ReviewOpts,
  ReviewResult,

  // Namespace types
  PRNamespace,
  IssuesNamespace,
  EpicsNamespace,
  GitNamespace,
  TodoNamespace,

  // Workflow types
  ParsedWorkflow,
  WorkflowMetadata,
  CompiledWorkflow,
  WorkflowRegistration,

  // Daemon types
  DaemonConfig
} from 'agents.mdx'
```

## Error Handling

Workflows should handle errors gracefully:

```typescript
on.issue.ready(async (issue) => {
  try {
    await issues.update(issue.id, { status: 'in_progress' })

    const result = await claude.do({ task: issue.title })

    // ... rest of workflow
  } catch (error) {
    console.error(`Workflow failed for ${issue.id}:`, error)

    // Mark as blocked for manual intervention
    await issues.update(issue.id, {
      status: 'blocked'
    })

    // Re-throw to mark workflow as failed
    throw error
  }
})
```

In cloud mode with durable transport, transient errors are automatically retried via `step.do()`.

## Next Steps

- [Workflow Examples](/docs/agents-workflows) - Complete workflow patterns
- [Architecture](/docs/architecture) - How agents.mdx integrates with todo.mdx
- [todo.mdx Package](/docs/todo-mdx) - Project context rendering
- [beads](/docs/beads) - Local issue tracking and dependencies
